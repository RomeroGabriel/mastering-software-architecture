{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Software Architecture","text":"<p>An one-stop Wiki for Software Architecture studies. A centralized repository for all things architecture! \ud83c\udfdb\ufe0f #SoftwareArchitectures</p>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>Fundamentals of Software Architecture</li> </ul> <p>*and of course chatGPT </p>"},{"location":"arch_characteristics/arch_characteristics/","title":"Architecture Characteristics","text":"<p>Architects must account for numerous factors when designing a software solution, including:</p> <ol> <li>Auditability;</li> <li>Performance;</li> <li>Security;</li> <li>Requirements;</li> <li>Data;</li> <li>Legality;</li> <li>Scalability;</li> </ol> <p>In software architecture, architects may collaborate on defining domain or business requirements. However, a <code>key responsibility involves identifying, discovering, and analyzing all the tasks that the software must perform beyond the domain functionality</code> \u2013 these are known as architectural characteristics. Architectural characteristics are sometimes referred to as <code>nonfunctional requirements</code>.</p> <p>Architecture characteristics can be divided into <code>implicit</code> and <code>explicit</code> types. Implicit characteristics, such as <code>availability, reliability, and security</code>, often <code>don't explicitly appear in requirements but are crucial</code> for project success. Architects must leverage their <code>domain knowledge</code> to unveil these characteristics during the analysis phase. For instance, a high-frequency trading firm might not explicitly mention low latency, but architects familiar with that domain understand its critical significance.</p> <p>An architectural characteristic meets three criteria:</p> <ol> <li>It specifies a design consideration unrelated to the domain.</li> <li>It impacts a structural aspect of the design.</li> <li>It is crucial or significantly contributes to the success of the application.</li> </ol>"},{"location":"arch_characteristics/arch_characteristics/#criteria-for-architectural-characteristics","title":"Criteria for Architectural Characteristics","text":""},{"location":"arch_characteristics/arch_characteristics/#specifies-a-nondomain-design-consideration","title":"Specifies a Nondomain Design Consideration","text":"<p>Architecture characteristics <code>define criteria for the successful operation and design of a system</code>. They outline <code>how requirements will be implemented and justify design choices</code>. For example, one common and significant architectural characteristic involves defining a specific performance level for the application. Often, this level of performance <code>isn't explicitly stated in the initial requirements document</code>.</p>"},{"location":"arch_characteristics/arch_characteristics/#influences-some-structural-aspect-of-the-design","title":"Influences Some Structural Aspect of the Design","text":"<p>Architects primarily focus on <code>describing architectural characteristics in projects</code> to address design considerations: <code>does a specific characteristic demand distinct structural attention for its success?</code> Take security, for instance - while it's a concern in nearly every project, basic precautions are usually integrated during design and coding. However, it becomes an architectural characteristic when the architect must devise something unique to address it, for example integrate an external payment processor.</p>"},{"location":"arch_characteristics/arch_characteristics/#is-critical-or-important-to-application-success","title":"Is critical or important to application success","text":"<p>Applications have the potential to accommodate numerous architectural characteristics, but this should be approached with caution. <code>Each added characteristic introduces complexity to the design</code>. Therefore, a vital task for architects is to focus on <code>selecting a minimal set of architecture characteristics rather than striving for the maximum possible</code>.</p>"},{"location":"arch_characteristics/arch_characteristics/#architectural-characteristics-partially-listed","title":"Architectural Characteristics (Partially) Listed","text":"<p>Architecture characteristics span from low-level code attributes to sophisticated operational concerns, such as scalability and elasticity. Additionally, as the software ecosystem evolves rapidly, new concepts, tools, and terms emerge, introducing novel characteristics. Operational architecture characteristics often <code>closely align with operations and DevOps considerations</code>, representing a significant intersection of these concerns within numerous software projects.</p>"},{"location":"arch_characteristics/arch_characteristics/#operational-architecture-characteristics","title":"Operational Architecture Characteristics","text":"<p>Operational architecture characteristics encompass capabilities such as performance, scalability, elasticity, availability, and reliability.</p> Tern Definition Availability How long the system will need to be available. Continuity Disaster recovery capability. <code>Performance</code> Involves stress testing, peak analysis, frequency of function usage, response times, etc. Can demand a dedicated effort and time. Recoverability Ensuring business continuity during disasters: How swiftly can recovery be achieved? This influences backup strategies and hardware redundancy needs. <code>Reliability/safety</code> Assess if the system needs to be fail-safe, or if it is mission critical in a way that affects lives. If it fails, what's happen? Robustness Ability to handle error and boundary conditions while running. <code>Scalability</code> Ability for the system to perform and operate as the number of users or requests increases."},{"location":"arch_characteristics/arch_characteristics/#structural-architecture-characteristics","title":"Structural Architecture Characteristics","text":"<p>These characteristics focus on code structure. Architects often bear the responsibility for code quality, including modularity, controlled component coupling, readability, and various internal quality evaluations.</p> Tern Definition <code>Configurability</code> Ability for the end users to easily change aspects of the software\u2019s configuration (through usable interfaces). <code>Extensibility</code> How important it is to plug new pieces of functionality in. <code>Installability</code> Ease of system installation on all necessary platforms. <code>Leverageability/reuse</code> Ability to leverage common components across multiple products. Localization Support for multiple languages. <code>Maintainability</code> How easy it is to apply changes and enhance the system? <code>Portability</code> Platforms that the system must support. Upgradeability Ability to easily/quickly upgrade from a previous version."},{"location":"arch_characteristics/arch_characteristics/#cross-cutting-architecture-characteristics","title":"Cross-Cutting Architecture Characteristics","text":"<p>Architecture characteristics that lack a definitive categorization yet form important design constraints and considerations.</p> Tern Definition Accessibility Access to all your users, including those with disabilities like colorblindness or hearing loss. Archivability Will the data need to be archived or deleted after a period of time? (For example, delete a user after three months inactive) <code>Authentication</code> Security requirements to ensure users are who they say they are. <code>Authorization</code> Security requirements to ensure users can access only certain functions within the application. Legal What legislative constraints is the system operating in. Privacy Ability to hide transactions from internal company employees (encrypted transactions so even DBAs and network architects cannot see them). <code>Security</code> Does the data need to be encrypted in the database? Encrypted for network communication between internal systems? What type of authentication needs to be in place for remote user access? <code>Supportability</code> What level of technical support is needed by the application? What level of logging and other facilities are required to debug errors in the system? Usability/achievability Level of training required for users to achieve their goals."},{"location":"arch_characteristics/arch_characteristics/#iso-architecture-characteristics-list","title":"ISO Architecture Characteristics List","text":"<p>It's basically impossible to list all characteristics, and many of the definitions overlap. The ISO's list describes some other characteristics as well.</p>"},{"location":"arch_characteristics/arch_characteristics/#trade-offs-and-define-architecture","title":"Trade-Offs and Define Architecture","text":"<p>Applications <code>can only support a subset</code> of the architecture characteristics due to various reasons. First, each supported characteristic <code>requires design effort and possibly structural support</code>. Second, a significant challenge arises from the fact that <code>each architecture characteristic often impacts others</code>, as seen in the example of security versus performance. Hence, architects rarely find themselves in a situation where they can design a system that maximizes every single architecture characteristic.</p> <p>Architects <code>should aim to design architecture that is as iterative as possible</code>. By enabling easier changes to the architecture, there's <code>less pressure to discover the exact correct solution</code> in the initial attempt. One of the crucial lessons from Agile software development is the value of iteration, which holds true across all levels of software development, including architecture.</p>"},{"location":"arch_characteristics/arch_characteristics/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"arch_characteristics/identifying_characteristics.md/","title":"Identifying Architectural Characteristics","text":"<p>It's really important identifying architectural characteristics to <code>start creating or checking an existing architecture</code>. To figure out the right architectural stuff, an architect needs to <code>understand the domain problem well</code>. Also, working together with domain stakeholders is crucial to <code>decide what really matters</code>.</p> <p>To find the architectural features in a project, there are at least three ways: you can get them from <code>domain concerns, project requirements, and and implicit domain knowledge</code>.</p>"},{"location":"arch_characteristics/identifying_characteristics.md/#extracting-architecture-characteristics-from-domain-concerns","title":"Extracting Architecture Characteristics from Domain Concerns","text":"<p>An architect must be able to <code>translate domain concerns to identify the right architectural characteristics</code>. By <code>understanding the key domain goals and domain situation</code>, the architect can <code>turn those worries into features</code>. These features then guide the smart choices for the architecture.</p> <p>One tip is when working with the domain stakeholders to decide the important architecture features, <code>try to keep the list of architectural characteristics short</code>. <code>Every feature added makes the design more complex and that's risky</code>. Don't get caught up in the number of features, but rather <code>focus on keeping the design simple</code>.</p>"},{"location":"arch_characteristics/identifying_characteristics.md/#architects-vs-stakeholders","title":"Architects vs Stakeholders","text":"<p>When architects and stakeholders are figuring out which architecture characteristics to focus on, it's a good idea to <code>let domain stakeholders choose the top three most important ones</code>. This <code>helps avoid problems since not everyone agrees</code> on the priority of each characteristic. This way, it's easier to <code>find common ground and helps the architect analyze trade-offs when making vital architecture decisions</code>.</p> <p>Most of the time, <code>architecture characteristics come from talking to key domain stakeholders and working together to figure out what matters</code>. The challenge is that architects and domain stakeholders use different terms. Architects talk about things like scalability and interoperability, while domain stakeholders talk about stuff like user happiness and getting things done quickly. The table below helps translate from domain concerns to architecture characteristics.</p> Domain concern Architecture characteristics Mergers and acquisitions Interoperability, scalability, adaptability, extensibility Time to market Agility, testability, deployability User satisfaction Performance, availability, fault tolerance, testability, deployability, agility, security Competitive advantage Agility, testability, deployability, scalability, availability, fault tolerance Time and budget Simplicity, feasibility <p>Translate from domain concerns to architecture characteristics from Fundamentals of Software Architecture.</p> <p>However, it's important to note that <code>this translation isn't a strict rule to blindly follow</code>. This is a common pitfall that many architects encounter when translating domain concerns. Being agile doesn't always mean getting to the market quickly. Time to market is a mix of agility, testability, and deployability. <code>Concentrating solely on one characteristic can lead to issues when trying to achieve goals</code>. For instance, focusing solely on performance when delivering a feature might cause availability problems when needed. And if the domain grows, will the system be able to scale?</p>"},{"location":"arch_characteristics/identifying_characteristics.md/#extracting-architecture-characteristics-from-requirements","title":"Extracting Architecture Characteristics from Requirements","text":"<p>Certain architecture characteristics are <code>derived from clear statements in requirements documents</code>, such as the expected number of users or peak usage times for the application. Others are <code>based on the inherent domain knowledge possessed by architects</code>. For example, an architect experienced in finance systems knows when and where to scale the software artifacts effectively.</p>"},{"location":"arch_characteristics/identifying_characteristics.md/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"arch_characteristics/measuring_governing/","title":"Measuring and Governing Architecture Characteristics","text":""},{"location":"arch_characteristics/measuring_governing/#measuring-architecture-characteristics","title":"Measuring Architecture Characteristics","text":"<p>Organizations often encounter various <code>common challenges when defining architecture characteristics</code>:</p> <ol> <li> They aren\u2019t physics Numerous commonly used <code>architecture characteristics have unclear definitions</code>. For instance, what exactly does it mean for an architect to design for agility or deployability? </li> <li> Wildly varying definitions Even within the same organization, it can be challenging to establish a shared understanding of features like performance. </li> <li> Too composite Many important <code>architecture characteristics actually consist of several smaller components.</code> For example, when we talk about agility, it involves things like modularity, deployability, and testability that contribute to it. </li> </ol> <p><code>Having clear and precise definitions for architecture characteristics</code> addresses these issues effectively. When an organization universally agrees on concrete definitions for these characteristics, it <code>establishes a shared language for discussing architecture</code>. Furthermore, by promoting objective definitions, teams can break down complex characteristics into specific, measurable features that they can define objectively.</p>"},{"location":"arch_characteristics/measuring_governing/#operational-measures","title":"Operational Measures","text":"<p>Numerous measurements have <code>nuanced interpretations depending on their specific goals</code>. Take, for instance, <code>measuring performance through the average response time for certain requests</code> \u2013 a prime example of operational architecture characteristics measurement. However, if teams solely focus on the average, they might <code>miss outliers caused by specific boundary conditions</code>, where 1% of requests take significantly longer than others. Hence, teams may also find it valuable to measure maximum response times to capture these outliers.</p> The variety of performance <p>Keep performance as example, architects and DevOps engineers have put in significant effort to <code>create performance budgets</code>, which are precise limits for various aspects of the application. For instance, an <code>ideal first-page render time</code> is set at 500 milliseconds\u2014half a second.</p> <p>Some of these metrics also carry <code>further implications for application design</code>. Forward-looking organizations often set size-based budgets for page downloads: a maximum limit for the amount of bytes allocated to libraries and frameworks on a given page.</p> <p>Top-tier teams don't just pick performance numbers out of thin air. <code>They use stats</code>. For example, say a video streaming service wants to monitor scalability. <code>Rather than set an arbitrary number as the goal, eengineers measure scalability over time, create statistical models, and sound alarms if real-time stats diverge from predictions.</code> A failure implies either a flawed model (good to know) or a problem (also good to know).</p>"},{"location":"arch_characteristics/measuring_governing/#structural-measures","title":"Structural Measures","text":"<p>Structural measures, unlike performance, <code>deal with code quality</code>, and unfortunately, we <code>don't have comprehensive metrics for internal code quality yet</code>. Nevertheless, there are some metrics and common tools that architects can use to address important aspects of code structure.</p> Cyclomatic Complexity Metric <p>Cyclomatic Complexity (CC) is a <code>code-level metric</code>. It offers a <code>quantifiable way to assess code complexity</code>, whether it's at the function/method, class, or application level.</p> <p>It is computed by <code>applying graph theory to code, specifically decision points, which cause different execution paths</code>. For example, if a function has no decision statements (such as if statements), then CC = 1. If the function had a single conditional, then CC = 2 because two possible execution paths exist.</p> <p>Architects and developers universally recognize that <code>excessively complex code is a code smell</code>. It undermines almost all the positive traits of codebases, like modularity, testability, deployability, and more. However, if teams <code>neglect monitoring the gradual increase in complexity, it can eventually overpower the entire codebase</code>.</p>"},{"location":"arch_characteristics/measuring_governing/#process-measures","title":"Process Measures","text":"<p>Certain <code>architecture characteristics align with software development processes</code>. Agility, for instance, is frequently seen as a valuable trait. Nevertheless, <code>it's a composite architecture characteristic that architects may break down into features like testability and deployability</code>.</p> Testability <p><code>Testability can be quantified using code coverage tools in testing</code>. However, it's essential to note that, like all software checks, <code>it cannot substitute critical thinking and intention</code>. For instance, a codebase might achieve 100% code coverage but still have weak assertions that don't genuinely ensure code correctness. Nonetheless, <code>testability is clearly an objectively measurable characteristic</code>.</p> Deployability <p>Teams can measure deployability via a variety of metricslike the success-to-failure deployment ratio, deployment duration, and more. <code>Teams need to determine suitable measurements that provide valuable data for their organization, focusing on quality and quantity</code>. These measurements often align with team priorities and objectives.</p> <p><code>Agility and its related aspects are closely tied to the software development process</code>. However, this process <code>can also influence the architecture's structure</code>. For instance, <code>if easy deployment and testability are high priorities, architects may focus more on robust modularity and isolation in the architecture</code> \u2013 an example of an architecture characteristic influencing a structural choice.</p>"},{"location":"arch_characteristics/measuring_governing/#governance-and-fitness-functions","title":"Governance and Fitness Functions","text":"<p>After architects define and prioritize architecture characteristics, <code>how can they ensure that developers prioritize those too?</code> In many software projects, urgency dominates, yet architects still require a governance mechanism.</p> <p><code>Architecture governance encompasses all aspects of the software development process that architects aim to influence</code>, such as maintaining software quality within an organization.</p> <p>There are increasingly advanced solutions available to help architects address this challenge. The book Building Evolutionary Architectures introduces a set of <code>techniques known as fitness functions, which can automate various aspects of this process.</code></p>"},{"location":"arch_characteristics/measuring_governing/#fitness-functions","title":"Fitness Functions","text":"<p>A fitness function is a <code>guidance mechanism</code>. It's a way to measure how closely the <code>output of an objective function aligns with achieving a specific goal</code>. For instance, when evaluating an algorithm that tackles the traveling salesperson problem, <code>one fitness function might check how long the route is and aim for the shortest one</code>. Another could look at <code>how much it costs and try to keep that cost low</code>. Yet another might consider how much time the salesperson is away and try to make the travel time shorter.</p> <p><code>Architecture fitness functions refer to any method that offers an objective evaluation of an architecture characteristic or a combination of them</code>. These functions encompass various verification methods, depending on their application: metrics, monitors, unit testing libraries, chaos engineering, and more.</p> <p>For more information and examples, Fitness function-driven development</p>"},{"location":"arch_characteristics/measuring_governing/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"arch_characteristics/scope/","title":"Scope of Architecture Characteristics","text":"<p>In the past, within the realm of software architecture, <code>the scope of architecture characteristics was traditionally placed at the system level</code>. For instance, scalability was discussed with the entire system in mind, as most systems were monolithic. However, <code>this is no longer accurate today</code>, as the field has evolved, exemplified by the emergence of microservices.</p> <p>There are various <code>code-level metrics</code> that enable architects to analyze the structural aspects of an architecture. However, these metrics often offer insights into low-level code specifics, <code>rather than the entirety of a system's components</code>. For example, databases can significantly influence various architecture characteristics, particularly operational ones. Code performance won't matter if the database doesn't scale.</p> <p>Architects must also consider <code>external components beyond the codebase that can influence these characteristics</code>. Furthermore, it's crucial to measure these types of dependencies.</p>"},{"location":"arch_characteristics/scope/#architectural-quanta-and-granularity","title":"Architectural Quanta and Granularity","text":"<p>To define the architecture quantum, we needed a measure of how components are \u201cwired\u201d together, which corresponds to the connascence concept. Connascence map dependencies between components, classifying them between static connascence or dynamic connascence.</p> <p>The definition about architecture quantum is:</p> <p>An independently deployable artifact with high functional cohesion and synchronous connascence</p> Independently deployable <p>An architectural quantum is a <code>self-sufficient unit that includes everything needed to work on its own within the larger architecture</code>. For instance, if an application relies on a database, the database is considered part of this self-contained unit because the application can't function without it..</p> High functional cohesion <p>Functional cohesion in component design <code>measures how well the code within a component serves a single, meaningful purpose</code>. In microservices architectures, high functional cohesion is particularly important because each service is typically designed to handle a specific workflow or function, ensuring clarity and efficiency in the system's organization.</p> Synchronous connascence <p>Synchronous connascence <code>refers to synchronous calls within an application context or between distributed services within an architecture quantum</code>. In a microservices architecture, when one service calls another synchronously, it's crucial that both services have similar operational architecture characteristics. If there's a significant difference in scalability between the caller and callee, issues like timeouts and reliability problems may arise.</p> <p>The concept of <code>architecture quantum provides the new scope for architecture characteristics</code>. In modern systems, <code>architects define these characteristics at the quantum level/specific parts</code>, rather than at the system level/whole system.  By <code>focusing on a more specific scope for essential operational concerns, architects can detect architectural challenges early</code>, which can lead to the development of hybrid architectures.</p>"},{"location":"arch_characteristics/scope/#choosing-between-monolithic-x-distributed-architectures","title":"Choosing Between Monolithic x Distributed Architectures","text":"<p>The choice between a monolithic and distributed architecture <code>depends on the scope of architecture characteristics</code>. A monolithic architecture consists of a single deployable unit that contains all system functionality and is typically connected to a single database. In contrast, a distributed architecture involves multiple services running independently, communicating through networking protocols.</p> <p>The decision hinges on how many architecture quanta are discovered during the design process. <code>If the system can function effectively with a single quantum (meaning one set of architecture characteristics), a monolithic architecture is advantageous</code>. However, <code>if different components require distinct architecture characteristics, a distributed architecture</code> is necessary to accommodate these variations.</p> <p>The ability to make this fundamental architectural decision early in the design process underscores the benefits of using the architecture quantum to analyze architecture characteristics' scope and coupling.</p>"},{"location":"arch_characteristics/scope/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"arch_styles/","title":"Architecture Styles","text":"<p><code>An architecture style refers to the overall structure of a software system, including how the user interface, backend code, and data storage are organized</code>. It encompasses decisions like whether to use a monolithic approach with all components together or a distributed approach with separate services.</p> <p>On the other hand, <code>architecture patterns are more detailed design structures that offer solutions within a specific architecture style</code>. These patterns address specific concerns, such as achieving scalability or optimizing performance for certain operations or services. They serve as practical templates for solving particular problems within the chosen architecture style.</p> <p>For new architects, <code>grasping different architecture styles is essential, as they form the foundation for making effective design decisions</code>. Each architecture style comes with its own set of trade-offs, which help architects choose the most suitable approach for a given business problem.</p>"},{"location":"arch_styles/foundations/","title":"Foundations","text":"<p>Architecture styles, sometimes called architecture patterns, <code>define how components relate to each other and cover various architectural characteristics</code>. These style names are like shortcuts for experienced architects. For example, if an architect talks about a 'layered monolith,' it signals specific structural aspects, what works well (or not), common deployment models, data strategies, and more.</p> <p><code>An architecture style describes the structure and typical architectural characteristics</code>, both good and bad. <code>Architects should also understand the fundamental patterns often found within these styles</code>.</p> Fundamental Patterns <p><code>Over time, some basic patterns keep showing up in software architecture. These patterns help us organize code and deployments</code>. For instance, the idea of separating different concerns based on functionality, into layers is an age-old concept in software. It's been around for a long time and still appears in various forms, even in modern architecture.</p>"},{"location":"arch_styles/foundations/#unitary-architecture","title":"Unitary Architecture","text":"<p>In the early days of software, <code>the computer and software were one</code>. But as technology evolved, they separated to handle more complex tasks. Mainframes, for instance, began as single systems but later split data into separate systems. Today, <code>unitary architectures are rare, except in specific situations like embedded systems</code>. Most software systems grow in complexity, so we separate them into different parts to keep them running smoothly.</p>"},{"location":"arch_styles/foundations/#client-server","title":"Client-Server","text":"<p>A fundamental style in architecture <code>separates technical functionality between frontend and backend</code>. This configuration is commonly referred to as a <code>two-tier or client/server architecture</code>. Over the years, this architectural approach has taken on various forms, adapting to different eras and advancements in computing technology.</p>"},{"location":"arch_styles/foundations/#desktop-database-server","title":"Desktop + Database Server","text":"<p>In the past, <code>desktop applications used to handle the user interface, while the data was stored in separate database servers accessible over networks</code>. This allowed desktops to handle user interfaces while heavy data processing happened on more powerful database servers.</p>"},{"location":"arch_styles/foundations/#browser-web-server","title":"Browser + Web Server","text":"<p>In this setup, <code>users interact with a web server, which connects to a database server</code>. It's similar to the desktop architecture but with lighter clients (browsers), making it more accessible. Although the database is separate, it's still considered two-tier because the web and database servers run on one machine in the data center, while the user interface is in the user's browser.</p>"},{"location":"arch_styles/foundations/#three-tier","title":"Three-tier","text":"<p>A popular architecture from the late 1990s is the three-tier architecture, <code>which adds more layers of separation</code>. <code>It includes a database tier with a powerful server, an application tier managed by an application server, and a frontend with HTML and JavaScript for user interfaces</code>.</p>"},{"location":"arch_styles/foundations/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"arch_styles/layered_arch/","title":"Layered Architecture Style","text":"<p>Layered architecture, or the <code>n-tiered architecture style</code>, is a widely used and popular architecture style in software development. Its popularity stems from its <code>simplicity, familiarity, and cost-effectiveness</code>. In most organizations, there are user interface (UI) developers, backend developers, rules developers, and database experts (DBAs). <code>This style seamlessly accommodates various roles in an organization</code>, making it a natural choice for many business applications. This architecture style is particularly <code>well-suited for applications that require a clear separation of concerns and modularity</code>. It allows for the division of an application into distinct layers, with each layer responsible for specific functions. Typically, these layers include:</p> <p>Presentation Layer (UI)</p> <p>This is the user interface layer responsible for handling user interactions. It often includes web pages or user interfaces in desktop applications.</p> <p>Business Logic Layer</p> <p>Also known as the application layer, this layer contains the core logic and business rules of the application. It processes requests from the presentation layer and communicates with the data access layer.</p> <p>Data Access Layer</p> <p>This layer is responsible for interacting with the database or data storage. It performs tasks such as data retrieval, storage, and manipulation.</p> <p>Database Layer</p> <p>This layer involves the actual database system where data is stored and managed.</p> <p>However, it is important to note that the layered architecture style is associated with certain <code>architectural anti-patterns</code>, such as the <code>architecture by implication anti-pattern</code> and the <code>accidental architecture anti-pattern</code>. These issues can arise when the development process <code>lacks proper planning or when the architecture is not explicitly defined</code>.</p> <p>In practical terms, <code>if developers or architects are uncertain about the architecture style</code> being employed, or if an Agile development team initiates coding without a clear architectural plan, <code>it is highly probable that they are adopting the layered architecture style</code>.</p>"},{"location":"arch_styles/layered_arch/#topology","title":"Topology","text":"<p>The layered architecture style <code>organizes components into distinct horizontal layers, each with a specific function within the application</code>. While the <code>number and types of layers can vary</code>, the typical layered architecture comprises four fundamental layers: presentation, business, persistence, and database. <code>Each layer assumes a defined role and responsibility, abstracting the necessary tasks to fulfill specific business requests</code>.</p> <p>Example</p> <p>For instance, the <code>presentation layer focuses on displaying information in a specific format, without requiring knowledge about data retrieval processes</code>. This segregation of concerns allows for the <code>establishment of clear role and responsibility models within the architecture</code>. Components within a particular layer are confined to tasks pertinent to that layer, ensuring a focused and modular approach to development.</p> <p>However, this structured separation in the layered architecture <code>can potentially lead to a decrease in overall agility, hampering the ability to swiftly adapt to changes</code>. As a technically partitioned architecture, i<code>t groups components by their technical roles rather than by business domains</code>. Consequently, a <code>specific business domain</code>, like \"customer,\" <code>spans various layers within the architecture, making it challenging to implement changes within that domain</code>. This characteristic makes it less suitable for the effective implementation of a domain-driven design approach.</p>"},{"location":"arch_styles/layered_arch/#deployment","title":"Deployment","text":"<p>The <code>deployment of the layered architecture style can take several physical layering forms, resulting in distinct topology variants.</code></p> <p>The First Variant</p> <p>The <code>presentation, business, and persistence layers into a singular deployment unit</code>. Simultaneously, the database layer remains external, often as a distinct physical database or filesystem.</p> <p>The Second Variant</p> <p>The <code>presentation layer is physically separated into its deployment unit</code>, while the <code>business and persistence layers are combined into a second deployment unit</code>. As in the first variant, the <code>database layer is typically segregated into an external database or filesystem</code>.</p> <p>The Third Variant</p> <p>The third variant amalgamates <code>all four standard layers, including the database layer, into a single deployment unit</code>. This approach proves beneficial for smaller applications, especially those utilizing either an internally embedded database or an in-memory database.</p> <p><code>The choice of a deployment variant should align with the specific requirements of the application</code>, including considerations related to application size, performance demands, and the necessity for scalability and flexibility.</p>"},{"location":"arch_styles/mono_distributed/","title":"Monolithic vs Distributed Architectures","text":"<p>There are <code>two primary categories</code>: monolithic and distributed architectures. These categories serve as a foundational distinction, even though it's important to note that <code>no classification is perfect</code>. <code>Distributed architectures, in particular, introduce a unique set of challenges that set them apart from monolithic architectures</code>. This classification offers a valuable way to differentiate between various architectural styles.</p>"},{"location":"arch_styles/mono_distributed/#monolithic-list","title":"Monolithic List","text":"<ol> <li>Layered Architecture</li> <li>Pipeline Architecture</li> <li>Microkernel Architecture</li> </ol>"},{"location":"arch_styles/mono_distributed/#distributed-list","title":"Distributed List","text":"<ol> <li>Service-based Architecture</li> <li>Event-driven Architecture</li> <li>Space-based Architecture</li> <li>Service-oriented Architecture</li> <li>Microservices Architecture</li> </ol>"},{"location":"arch_styles/mono_distributed/#fallacies-of-distributed-computing","title":"Fallacies of Distributed Computing","text":"<p>Distributed architectures <code>can be more</code> powerful in terms of performance, scalability, and availability than monolithic architecture styles, <code>but they come with trade-offs</code>. <code>Some common misconceptions, can lead to false assumptions in distributed systems</code>. Understanding these misconceptions is crucial in designing distributed architectures.</p>"},{"location":"arch_styles/mono_distributed/#the-network-is-reliable","title":"The Network Is Reliable","text":"<p><code>People often assume that networks are reliable, but they're not</code>. Even though networks have improved, they can still be unreliable. <code>This is critical in distributed architectures because they heavily depend on network communication</code>. Measures like timeouts and circuit breakers are used to manage this unpredictability, especially in systems like microservices. <code>The more a system relies on the network, the less reliable it can be</code>. Latency in any distributed architecture is not zero, yet most architects ignore this fallacy, insisting that they have fast networks.</p>"},{"location":"arch_styles/mono_distributed/#latency-is-zero","title":"Latency Is Zero","text":"<p><code>Local calls between components are faster than remote ones using protocols like REST, messaging, or RPC</code>. <code>Knowing the average round-trip latency for remote calls is crucial in distributed architectures</code>, especially microservices.</p> Calculating Latency <p>If the average latency is 100 milliseconds, chaining 10 service calls adds 1,000 milliseconds to a request. <code>However, it's not just the average latency that matters; the 95th to 99th percentile can significantly impact performance</code>. So, understanding these latencies is vital for architecting distributed systems.</p>"},{"location":"arch_styles/mono_distributed/#bandwidth-is-infinite","title":"Bandwidth Is Infinite","text":"<p>In monolithic architectures, <code>bandwidth is typically not a concern because processing within a monolith often requires little to no additional bandwidth</code>. However, in distributed systems, <code>communication between services can consumes significant bandwidth, which can lead to network slowdowns</code>.</p> <p>When a service needs to connect to other services to process requests, it consumes bandwidth. This can become problematic, especially if these requests occur frequently. This situation, known as <code>stamp coupling</code>, can have a significant impact on bandwidth usage. <code>To address stamp coupling in distributed architectures, there are several approaches you can consider</code>:</p> <ol> <li>Create private RESTful API endpoints.</li> <li>Use field selectors in the contract.</li> <li>Adopt GraphQL to decouple contracts.</li> <li>Combine value-driven contracts with consumer-driven contracts (CDCs).</li> <li>Leverage internal messaging endpoints.</li> </ol> <p>Tip</p> <p>No matter which approach you choose, <code>the key is to minimize the amount of data transferred between services or systems in a distributed architecture</code>. This is essential for addressing the fallacy of infinite bandwidth.</p>"},{"location":"arch_styles/mono_distributed/#the-network-is-secure","title":"The Network Is Secure","text":"<p>In the world of distributed computing, it's common for architects and developers to rely on tools like virtual private networks (VPNs), trusted networks, and firewalls, which can create a false sense of security. However, <code>it's crucial to remember that the network itself is not inherently secure</code>.</p> <p><code>Security becomes a much more complex challenge in distributed architectures</code>. In such systems, <code>every endpoint, associated with each distributed deployment unit, must be diligently secured to prevent unauthorized or malicious requests from reaching those services</code>. As you transition from a monolithic to a distributed architecture, the potential surface area for security threats and attacks increases significantly.</p> <p><code>Ensuring the security of every endpoint, even during interservice communication, is a demanding task</code>. This is one of the reasons why <code>synchronous</code>, highly-distributed architectures like microservices or service-based architecture often exhibit slower performance. The need to address security at every level introduces additional overhead and complexity.</p>"},{"location":"arch_styles/mono_distributed/#the-topology-never-changes","title":"The Topology Never Changes","text":"<p>This fallacy <code>assumes that the overall network structure</code>, including routers, hubs, switches, firewalls, and other network components, remains static and <code>never undergoes changes. However, in reality, network topologies can and do change</code>.</p> <p><code>Architects should recognize that network topologies are dynamic</code> and may evolve over time. <code>It's crucial for architects to maintain open communication with network administrators and operations teams to stay informed about any changes to the network infrastructure</code>. This awareness allows architects to adapt and make necessary adjustments to ensure the reliability and performance of distributed systems, minimizing unwelcome surprises.</p>"},{"location":"arch_styles/mono_distributed/#there-is-only-one-administrator","title":"There Is Only One Administrator","text":"<p>Architects often make the <code>mistake of assuming they only need to collaborate and communicate with a single administrator when dealing with network issues</code>. This fallacy <code>highlights the complexity of distributed architecture and the need for extensive coordination</code>.</p> <p><code>In distributed architectures, effective communication and collaboration with multiple administrators are essential</code>. Unlike monolithic applications, where a single deployment unit simplifies administration, distributed systems require architects to engage with various network administrators to ensure everything functions correctly.</p>"},{"location":"arch_styles/mono_distributed/#transport-cost-is-zero","title":"Transport Cost Is Zero","text":"<p>The term <code>transport cost</code> in this context doesn't refer to how quickly data travels, but to the <code>actual expenses incurred when making what seems like a simple RESTful call.</code> Architects often mistakenly assume that the existing infrastructure is enough for such calls or for breaking down a monolithic application. However, this isn't usually the case.</p> <p><code>Distributed architectures typically come with significantly higher expenses compared to monolithic ones</code>. This increase in cost is primarily due to the need for extra hardware, servers, gateways, firewalls, the creation of new subnets, proxies, and other resources.</p> <p>When architects dive into <code>designing a distributed architecture, it's essential to thoroughly assess the current server and network infrastructure</code>. This assessment should consider factors like capacity, bandwidth, latency, and security zones. By doing this, architects can avoid being caught off guard by unexpected costs and plan more effectively.</p>"},{"location":"arch_styles/mono_distributed/#the-network-is-homogeneous","title":"The Network Is Homogeneous","text":"<p>Many architects and developers often assume that networks are homogeneous, consisting of hardware from a single vendor. In reality, <code>most companies have a mix of network hardware vendors in their infrastructure, and sometimes, even more than that</code>. The importance of this fallacy lies in the fact that <code>not all of these diverse hardware vendors seamlessly cooperate with one another</code>. While most components work together, questions arise about the seamless integration of Juniper hardware with Cisco hardware, for instance.</p> <p><code>While networking standards have progressed over the years, reducing this problem, the fact remains that not all scenarios, loads, and circumstances have been thoroughly tested</code>. Consequently, network packets can occasionally get lost, causing issues.</p>"},{"location":"arch_styles/mono_distributed/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> <li>The 95th and 99th percentiles are the most crucial application metrics</li> <li>What are 99 percentile and 95 percentile?</li> </ul>"},{"location":"basic/architectural_thinking/","title":"Architectural Thinking","text":"<p>A software architecture goes beyond mere \"thinking about the architecture.\" It encompasses various crucial aspects that architects need to consider, including:</p> <ul> <li> <p>Architecture vs. Design: It is important to distinguish between architecture and design and effectively collaborate with development teams to align their efforts.</p> </li> <li> <p>Technical Breadth: It involves having a broad range of technical knowledge while maintaining a certain level of depth. This allows architects to see solutions and possibilities that others do not see.</p> </li> <li> <p>Analyzing Trade-Offs: Architects should understand, analyze, and reconcile trade-offs between different solutions and technologies.</p> </li> <li> <p>Understanding Business Drivers: Understand the importance of business drivers and how they translate to architectural concerns.</p> </li> </ul>"},{"location":"basic/architectural_thinking/#architecture-vs-design","title":"Architecture vs. Design","text":"<p>The distinction between architecture and design can be confusing at times. It raises questions about the roles and responsibilities of architects compared to developers. However, an architect possesses the knowledge and understanding to differentiate between architecture and design. They recognize how these two aspects intricately intertwine to create comprehensive solutions for both business and technical challenges.</p>"},{"location":"basic/architectural_thinking/#traditional-and-wrong-thinking","title":"Traditional and Wrong Thinking","text":"<p>Traditional view of architecture versus design from Fundamentals of Software Architecture.</p> <p>The traditional viewpoint described in the image below is rarely effective. It often leads to a disconnect between the architect and the development team. Architectural decisions made by the architect may not reach the development team, and conversely, decisions made by the development team may not be communicated back to the architect. This lack of communication and coordination can result in changes to the architecture that were never intended or considered by the architect.</p>"},{"location":"basic/architectural_thinking/#the-right-thinking","title":"The Right Thinking","text":"<p>Making architecture work through collaboration from Fundamentals of Software Architecture.</p> <p>For effective architecture, there should be no barriers between architects and developers. It is crucial to establish a strong, bi-directional relationship between them. This allows architects to provide mentoring and coaching to the development team. Architecture and design are intertwined aspects within the software project lifecycle and must always collaborate closely.</p>"},{"location":"basic/architectural_thinking/#technical-breadth","title":"Technical Breadth","text":"<p>A significant aspect of an architect's value lies in their comprehensive understanding of technology and its application to solving specific problems. Rather than having expertise in only one solution, it is more advantageous for an architect to be aware of multiple solutions available for a given problem.</p> <p>In the realm of architecture, breadth of knowledge outweighs depth. Architects are tasked with making decisions that align capabilities with technical constraints. Therefore, having a broad understanding of a wide range of solutions holds immense value.</p>"},{"location":"basic/architectural_thinking/#analyzing-trade-offs","title":"Analyzing Trade-Offs","text":"<p>Architecture is the stuff you can\u2019t Google. There are no right or wrong answers in architecture\u2014only trade-offs. Programmers know the benefits of everything and the trade-offs of nothing. Architects need to understand both.</p> <p>Adopting an architectural mindset involves recognizing trade-offs in every solution, whether they are technical or non-technical, and meticulously analyzing them to determine the optimal choice.</p> <p>In architecture, trade-offs permeate every aspect, which is why the universal response to architecture questions is often \"it depends.\" The optimal solution hinges on various factors such as the deployment environment, business drivers, company culture, budgets, timeframes, developer skill sets, and numerous other considerations.</p> <p>As an architect, the ability to navigate these trade-offs is crucial. It entails carefully evaluating the benefits and drawbacks of different options and striking a balance that aligns with the specific project requirements and constraints. Making informed decisions based on a thorough analysis of trade-offs ensures the chosen solution is well-suited to the unique context of the architecture project.</p>"},{"location":"basic/architectural_thinking/#understanding-business-drivers","title":"Understanding Business Drivers","text":"<p>Thinking like an architect entails comprehending the essential business drivers necessary for the system's success and effectively translating those requirements into architectural characteristics like scalability, performance, and availability. This task presents a significant challenge, as it demands architects to possess a certain level of business domain knowledge and foster collaborative relationships with key business stakeholders. By understanding the underlying business needs and aligning them with the architectural decisions, architects can design solutions that meet both technical and business objectives, ensuring the overall success of the system.</p>"},{"location":"basic/architectural_thinking/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"basic/expectations_of_architect/","title":"Expectations of an Architect","text":"<p>Defining the role of a software architect can be challenging, as it encompasses various aspects. However, it is essential to outline the expectations and responsibilities associated with the architect's role.</p> <ul> <li>Make architecture decisions</li> <li>Continually analyze the architecture</li> <li>Keep current with latest trends</li> <li>Ensure compliance with decisions</li> <li>Diverse exposure and experience</li> <li>Have business domain knowledge</li> <li>Possess interpersonal skills</li> <li>Understand and navigate politics</li> </ul>"},{"location":"basic/expectations_of_architect/#make-architecture-decisions","title":"Make architecture decisions","text":"<p>An architect is expected to define the architecture decisions and design principles used to guide technology decisions within the team, the department, or across the enterprise.</p> <p>When it comes to making architecture decisions, guidance is crucial. Instead of strictly specifying technology choices, the role of an architect  should guide rather than specify technology choices.</p> <p>For instance, rather than explicitly stating that React.js should be used for the frontend, which is a technical decision, the architect should guide development teams towards choosing a reactive-based framework for the frontend, offering options like Angular, React.js, Vue.js, and others. It is important to assess whether the architecture decision is guiding teams to make their own technical choices or if it imposes a specific technology upon them, which may hinder their decision-making process.</p> <p>While the role of an architect primarily focuses on guiding rather than specifying technology choices, there are situations where specific technology decisions become necessary to preserve a particular architectural characteristics like scalability, performance, or availability. Even though these decisions involve choosing a particular technology, they still fall within the realm of architectural decisions.</p> <p>However, it's important to acknowledge that finding the right decision in such cases can be challenging. The topic of making architecture decisions will be further explored and discussed in subsequent sections.</p>"},{"location":"basic/expectations_of_architect/#continually-analyze-the-architecture","title":"Continually analyze the architecture","text":"<p>An architect is expected to continually analyze the architecture and current technology environment and then recommend solutions for improvement.</p> <p>This responsibility refers to architecture vitality, analyzing how well the architecture can sustain itself over time. It is not a common concern, as many architectures encounter structural decay when developers introduce code or design changes that affect the required architectural characteristics.</p> <p>Additionally, testing and release environments often tend to be overlooked in this context. If the testing and release processes consume excessive time, it becomes challenging to achieve overall agility in the architecture.</p>"},{"location":"basic/expectations_of_architect/#keep-current-with-latest-trends","title":"Keep current with latest trends","text":"<p>An architect is expected to keep current with the latest technology and industry trends.</p> <p>Keeping up with the latest trends is crucial for staying relevant in the field of architecture. The decisions made by an architect often have long-lasting effects and can be challenging to modify later on. By actively staying informed about and embracing key trends, architects can better prepare for the future and make well-informed decisions that align with industry advancements. This proactive approach ensures that architectural decisions are forward-thinking and capable of meeting evolving needs and challenges.</p>"},{"location":"basic/expectations_of_architect/#ensure-compliance-with-decisions","title":"Ensure compliance with decisions","text":"<p>An architect is expected to ensure compliance with architecture decisions and design principles.</p> <p>One of the key responsibilities of an architect is to ensure that development teams are following the architecture decisions and design principles. By enforcing compliance, the architect helps prevent violations that could compromise the desired architectural characteristics and impede the expected functionality of the application or system.</p> <p>For instance, consider a scenario where there is a restriction on database access, allowing only the business and services layers (excluding the presentation layer) to communicate with the database. This architectural decision necessitates passing through all layers, even for a simple query originating from the presentation layer. However, this decision serves a specific purpose: to control changes. By enforcing this approach, database modifications can be implemented without affecting the presentation layer, thus ensuring a greater degree of flexibility and mitigating potential disruptions.</p>"},{"location":"basic/expectations_of_architect/#diverse-exposure-and-experience","title":"Diverse exposure and experience","text":"<p>An architect is expected to have exposure to multiple and diverse technologies, frameworks, platforms, and environments.</p> <p>As an architect, it is not necessary to be an expert in every framework, platform, or programming language. However, it is crucial to have a diverse exposure and familiarity with a variety of technologies. This includes knowing how to interface with multiple systems and services based on different technologies.</p> <p>A skilled software architect actively seeks opportunities to gain experience in various languages, platforms, and technologies. Rather than focusing solely on technical depth, it is important to prioritize technical breadth. For example, instead of being an expert in just one caching product, it is more valuable for an architect to be familiar with the features, advantages, and disadvantages of multiple caching products. This broader understanding allows for informed decision-making when choosing the most suitable caching solution for a given scenario.</p> <p>By continuously expanding their technical breadth, an architect can effectively navigate diverse technology landscapes, make informed decisions, and provide valuable guidance in selecting the right tools and technologies for a project. This breadth of exposure and experience enhances their ability to design robust and scalable solutions that align with business requirements.</p>"},{"location":"basic/expectations_of_architect/#have-business-domain-knowledge","title":"Have business domain knowledge","text":"<p>An architect is expected to have a certain level of business domain expertise.</p> <p>Having a strong understanding of the business domain is a fundamental expectation for an architect. Without this knowledge, it becomes challenging to comprehend the business problem, goals, and requirements, making it difficult to devise an effective architecture. Additionally, lacking business domain knowledge diminishes the architect's credibility when communicating with stakeholders and business users.</p>"},{"location":"basic/expectations_of_architect/#possess-interpersonal-skills","title":"Possess interpersonal skills","text":"<p>An architect is expected to possess exceptional interpersonal skills, including teamwork, facilitation, and leadership.</p> <p>Being an effective software architect involves more than just providing technical guidance. It requires possessing strong interpersonal skills and the ability to lead development teams through the implementation of the architecture. In fact, leadership skills are considered equally important, if not more so, than technical expertise for a successful architect.</p>"},{"location":"basic/expectations_of_architect/#understand-and-navigate-politics","title":"Understand and navigate politics","text":"<p>An architect is expected to understand the political climate of the enterprise and be able to navigate the politics.</p> <p>In the realm of software architecture, it is essential for architects to possess the ability to understand and navigate the intricacies of organizational politics. While developers often have the freedom to make alterations like refactoring code using the strategy pattern without seeking approval, architects face different challenges.</p> <p>Consider a scenario where an architect is responsible for a large customer relationship management (CRM) system and encounters issues with controlling database access from other systems. To address this, the architect decides to implement application silos, ensuring that each application's database is accessible only to the corresponding application. This decision empowers the architect to have better control over customer data, security, and change control.</p> <p>However, unlike the previous developer scenario, architectural decisions of this magnitude are likely to be met with resistance from various stakeholders within the company. For instance, if other applications can no longer access the database directly, they would need to request data from the CRM system through remote access calls using protocols like REST or SOAP. This shift in approach triggers challenges from different quarters. Product owners, project managers, and business stakeholders may express concerns about increased costs or additional effort required. Developers may also challenge the decision, presenting alternative approaches they believe to be superior.</p> <p>In such situations, architects must skillfully navigate the company's politics and employ effective negotiation techniques to gain approval for their decisions.</p>"},{"location":"basic/expectations_of_architect/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"basic/whats_software_arc/","title":"What is Software Architecture?","text":"<p>Software Architecture is a dynamic and complex field that continues to evolve rapidly. Recent years have witnessed advancements such as CI/CD, microservices, containerization, and cloud-based resources. These innovations bring new capabilities and trade-offs to consider.</p> <p>In software development, understanding trade-off analysis is crucial for making informed decisions. This repository emphasizes analyzing trade-offs rather than passing judgments on technologies.</p> <p>It is crucial to recognize that architectures are shaped by their context. Architectural decisions are often influenced by the realities of the environment they operate in. For instance, attempting to implement a microservices architecture in 2002 would have been impractical.</p>"},{"location":"basic/whats_software_arc/#defining-software-architecture","title":"Defining Software Architecture","text":"<p>Defining Software Architecture is challenging due to various interpretations. It may be seen as the blueprint or roadmap for a system. However, what aspects does an architect analyze when examining an architecture?</p> <p>One definition in Fundamentals of Software Architecture is illustrated on the image bellow. In this definition, software architecture consists of the structure of the system, combined with architecture characteristics the system must support, architecture decisions, and design principles.</p> <p></p> <p>Architecture consists of the structure combined with architecture characteristics (\u201c-ilities\u201d), architecture decisions, and design principles</p>"},{"location":"basic/whats_software_arc/#structure","title":"Structure","text":"<p>Structure refers to the type of architecture styles used in the system</p> <p>The system structure refers to the architecture style(s) implemented in the system, like microservices, layered, or microkernel. However, it's important to note that the system structure alone does not fully describe a system architecture.</p>"},{"location":"basic/whats_software_arc/#architecture-characteristics","title":"Architecture characteristics","text":"<p>Architecture characteristics refers to the \u201c-ilities\u201d that the system must support</p> <p>Architecture characteristics define the success criteria for a system, independent of its functionality. They are essential for the system to function correctly and do not necessarily rely on knowing the specifics of its functionality.</p>"},{"location":"basic/whats_software_arc/#architecture-decisions","title":"Architecture decisions","text":"<p>Architecture decisions are rules for constructing systems</p> <p>Architecture decisions establish the guidelines for system construction. They impose constraints and provide direction to development teams, outlining what is permissible and what is not within the system.</p>"},{"location":"basic/whats_software_arc/#design-principles","title":"Design principles","text":"<p>Design principles are guidelines for constructing systems</p> <p>The design principles is a guideline rather than a hard-and-fast rule like architecture decisions. As an example, the design principle depicted in the image above guides development team to utilize asynchronous messaging for improved performance in a microservice architecture. Architecture decisions cannot account for every communication scenario between services. Hence, design principles offer guidance, such as employing async messaging, enabling developers to choose suitable communication protocols like REST or gRPC.</p>"},{"location":"basic/whats_software_arc/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"components/","title":"Components","text":"<p>Modules are groups of related code, but architects often focus on <code>components, which are the physical versions of modules</code>. These components are packaged differently depending on the programming language, such as jar files in Java or DLLs in .NET.</p>"},{"location":"components/#component-scope","title":"Component Scope","text":"<p>Components provide a language-specific way to group artifacts together, often by nesting them to create layers. It's helpful to divide the concept of components as shown in the image below.</p> <p></p> <p>Different varieties of components from Fundamentals of Software Architecture.</p> Wrapper of Related Code <p>The simplest form of a component is one that <code>wraps code at a higher level of modularity than classes or functions</code>. This is often <code>referred to as a library</code>. Libraries typically run in the same memory address as the calling code and communicate via language function call mechanisms. Libraries are usually compile-time dependencies.</p> Layer or Subsystem &amp; Event Processor <p>Components can also take the form of subsystems or layers within an architecture, serving as the deployable units of work for many event processors.</p> Distributed Service <p>Distributed services tend to <code>run in their own separate address spaces and communicate</code> using low-level networking protocols like TCP/IP or higher-level formats like REST or message queues. <code>They are stand-alone and deployable units in architectures</code> such as microservices.</p> <p><code>Components are the basic building blocks in architecture</code> and are a crucial consideration for architects. <code>One of the key decisions architects must make is how to divide the architecture into top-level components</code>. While architects are not obligated to use components, they often find them beneficial as they provide a higher level of modularity.</p>"},{"location":"components/#architect-role","title":"Architect Role","text":"<p><code>The architect typically plays a central role in defining, refining, managing, and overseeing components within an architecture</code>.  This work is done in collaboration with various stakeholders, including business analysts, subject matter experts, developers, QA engineers, operations teams, and enterprise architects, to create the initial software design.</p> <p>In most cases, components represent the lowest level of the software system that an architect directly interacts with. These components are composed of classes or functions, depending on the implementation platform. The detailed design of these classes or functions often falls under the responsibility of tech leads or developers. While <code>architects may involve themselves in class design, especially when applying design patterns, they should avoid micromanaging every decision throughout the system</code>. Allowing other roles to make significant decisions is essential for empowering the next generation of architects.</p> <p><code>One of the architect's initial tasks on a new project is to identify components</code>. However, before doing so, architects must have a clear understanding of how to partition the overall architecture effectively.</p>"},{"location":"components/#architecture-partitioning","title":"Architecture Partitioning","text":"<p>In software architecture, <code>there are always trade-offs to consider, including how architects design components within an architecture</code>. <code>Components serve as general containers, allowing architects to structure the system as they see fit</code>. There are several common styles available, each with its own set of trade-offs to consider.</p> <p>Let's consider two common architecture styles shown below.</p> <p></p> <p>Two types of top-level architecture partitioning: layered and modular from Fundamentals of Software Architecture.</p> Technical Partitioning as a version of Layer Monolith <p>In the layer monolith, <code>the architecture is divided into layers</code> each with specific responsibilities.</p> Domain Partitioning as a version of Modular Monolith <p>In the modular monolith, <code>organized around domains or business functionalities</code></p> <p>It's important to note that in each of these variations, <code>the top-level components (layers or components) often contain embedded sub-components</code>. The choice of <code>top-level partitioning is a critical decision for architects, as it defines the fundamental architecture style and the way code is organized</code>.</p>"},{"location":"components/#technical-partitioning","title":"Technical Partitioning","text":"<p>When organizing a codebase <code>through technical partitioning, code is grouped based on its technical aspects</code>.  For instance, code responsible for interacting with a database is placed in the persistence layer. This approach ensures that <code>code with similar technical concerns resides within a single layer of the architecture</code>.</p> Model-View-Controller (MVC) <p>One classic example of this approach is the <code>Model-View-Controller (MVC)</code> design pattern. <code>MVC separates code into distinct components</code>, including the model (data and logic), view (user interface), and controller (intermediary between model and view). <code>This separation simplifies code organization and enhances comprehensibility</code>.</p> <p>In technical partitioning, a key principle is to separate technical concerns. <code>This separation results in different levels of decoupling</code>. For instance, if we consider the <code>service layer</code>, it's primarily connected to the persistence layer below it and the business rules layer above it. <code>This means that any changes made to the persistence layer will likely only impact these adjacent layers</code>.</p> <p>This partitioning style is valuable because it <code>minimizes the potential for changes in one part of the system to create significant impacts on other components</code>. It helps reduce the cascading effects of modifications on dependent parts of the architecture.</p> <p>In layered architecture, <code>there's an interesting impact on how companies organize their project teams.</code> It often leads to a situation where backend developers work together in one department, database administrators (DBAs) in another, and the presentation team in yet another department.</p>"},{"location":"components/#domain-partitioning","title":"Domain Partitioning","text":"<p>Another way to structure architecture is through domain partitioning, which is <code>inspired by the Domain-Driven Design (DDD) approach</code>. In DDD, architects <code>identify separate and independent domains or workflows</code> within a complex software system. While each of these domains may have its own layers, such as a business rules layer and its own persistence library, <code>the main focus of domain partitioning is on these separate domains</code>. For instance, CatalogCheckout represents a specific domain within your system. And may have a diffent persistence library than others components.<code>This approach aligns well with how changes typically happen in projects</code>.</p> <p>In a <code>technically layered architecture, a common business workflow like CatalogCheckout is spread across multiple layers</code>, with code related to it present in each layer. However, in <code>domain partitioning, CatalogCheckout's code is concentrated within its own sub-component</code>, resulting in a more focused and organized structure.</p>"},{"location":"components/#developer-role","title":"Developer Role","text":"<p>Developers often work with components that have been collaboratively designed with architects, breaking them down into classes, functions, or subcomponents. The responsibility for designing classes and functions is usually shared among architects, tech leads, and developers, with a significant portion falling on the developer's shoulders.</p> <p><code>It's important to note that developers shouldn't consider the architect's design as final</code>. Software design is an iterative process, and the initial design should be seen as a starting point. During implementation, more details and refinements may emerge, leading to improvements in the design.</p>"},{"location":"components/#component-identification-flow","title":"Component Identification Flow","text":"<p>Identifying components is <code>best achieved through an iterative process that generates candidates and refines them based on feedback</code>. The following stages outline a typical component identification workflow. In certain specialized domains, additional steps may be introduced, such as security or auditing procedures, to adapt to specific requirements.</p> Identifying Initial Components <p>In the early stages of a software project, <code>architects face the task of determining the initial top-level components</code>. This choice is <code>influenced by the type of</code> top-level partitioning they select. Beyond this, architects have the creative freedom to define components as they see fit, and then align domain functionality with these components to <code>determine where specific behaviors should reside</code>.</p> <p>It's important to note that <code>achieving an optimal design with this initial set of components is quite challenging</code>. This is why architects must engage in an iterative process of component design refinement to enhance the overall system design.</p> Assign Requirements to Components <p>Once an architect has identified the initial components, the <code>next step is to see how the project's requirements or user stories fit with these components</code>. It might involve creating new components, consolidating existing ones, or even splitting components if they carry too much responsibility.</p> <p>Remember, <code>this doesn't have to be super precise right away. The main goal is to create a basic structure that can be adjusted and improved</code> as the project progresses, with input from architects, tech leads, and developers.</p> Analyze Roles and Responsibilities <p>The architect also <code>checks if the roles and responsibilities mentioned in the requirements match the component granularity</code>. This means making sure that the way people and tasks are organized aligns with how the components are structured. <code>Finding the right level of granularity for components can be challenging, which is why this iterative process is crucial</code>.</p> Analyze Architecture Characteristics <p><code>When assigning requirements to components, architects should consider the previously identified architecture characteristics</code>. For example, if one part of the system deals with many users simultaneously, and another part with only a few, their architectural needs will vary. While a simple approach might suggest one component for user interaction, analyzing the architecture characteristics may lead to splitting it into multiple components. <code>This helps tailor the design to the system's specific requirements</code>.</p> Restructure Components <p><code>Feedback plays a crucial role in software design</code>. Architects must continuously refine their component design in collaboration with developers. <code>Designing software often presents unexpected challenges, and it's impossible to anticipate every issue that may arise</code>. Therefore, an iterative approach to component design is essential.</p> <p>Firstly, it's challenging to foresee all the unique scenarios and edge cases that might require redesign. Secondly, <code>as the architecture and development progress, a more nuanced understanding of where specific functions and responsibilities should reside emerges</code>. This iterative process allows for a more robust and adaptable software design.</p>"},{"location":"components/#component-design","title":"Component Design","text":"<p>Creating a component design involves <code>many techniques, each with its own pros and cons</code>. <code>The architect's job is to analyze requirements and decide on the fundamental building blocks for the application</code>. These techniques vary depending on the team's development process and organizational preferences.</p> <p>Architects, often <code>working with others, establish an initial component design based on their understanding of the system and their chosen approach for breaking it down</code>, whether by technical or domain considerations. The aim is to create an <code>initial design that divides the problem into manageable chunks while considering various architecture aspects</code>.</p> Entity Trap <p>The entity trap is a common anti-pattern illustrated in the image below.</p> <p></p> <p>Building an architecture as an object-relational mapping from Fundamentals of Software Architecture.</p> <p>It occurs when an architect <code>creates components for each entity identified in the requirements, resembling an object-relational mapping (ORM) framework for a database</code>. This approach is not true architecture but rather a way to handle simple database CRUD operations. ORM frameworks are available for this purpose.</p> <p>The problem with the entity trap is that it <code>inaccurately maps database relationships to application workflows, which is rarely the case in practice</code>. This anti-pattern typically reflects a <code>lack of consideration for the actual application workflows</code>.</p>"},{"location":"components/#actoractions-approach","title":"Actor/Actions Approach","text":"<p>The actor/actions approach is a common method that architects use to align requirements with components. In this approach, inspired by the Rational Unified Process, <code>architects identify actors who interact with the application and define the actions these actors can perform</code>. This approach helps discover the typical users of the system and the actions they might take.</p> <p>The actor/actions approach remains popular and is <code>effective when requirements involve distinct roles and their associated actions</code>. <code>This method of component design is suitable for various types of systems, whether they are monolithic or distributed</code>.</p>"},{"location":"components/#event-storming-approach","title":"Event Storming Approach","text":"<p>The event storming approach to component discovery originates from domain-driven design (DDD) and is closely associated with microservices. In event storming, <code>the architect anticipates that the project will rely on messages and events for communication between components</code>. To implement this, <code>the team identifies the events that take place in the system based on requirements and identified roles</code>. Components are then built around these event and message handlers. <code>This approach is particularly effective in distributed architectures like microservices that heavily rely on events and messages, as it assists architects in defining the messages used in the system</code>.</p>"},{"location":"components/#workflow-approach","title":"Workflow Approach","text":"<p>An alternative to event storming, <code>which provides a more generic option for architects who are not utilizing domain-driven design (DDD) or messaging</code>. In the workflow approach, c<code>omponents are designed around workflows, similar to event storming, but without the specific requirement of constructing a message-based system</code>. <code>This approach involves identifying key roles, determining the types of workflows these roles are involved in, and then creating components based on these identified activities</code>.</p>"},{"location":"components/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"},{"location":"modularity/","title":"Modularity","text":"<p>95% of the words [about software architecture] are spent extolling the benefits of \u201cmodularity\u201d and that little, if anything, is said about how to achieve it.</p> <p>Modularity is a <code>fundamental organizing principle</code> in software architecture. If an architect neglects how the components of a system interconnect, it can lead to numerous problems.</p> <p>Although the concept of modularity is widely recognized in software architecture, it can be elusive to precisely define. These modules serve as a <code>means of encapsulating functionality, promoting code organization, and enhancing maintainability</code>.</p> <p>Maintaining good modularity embodies an <code>implicit architectural characteristic</code>: most projects may not explicitly demand the architect to ensure it, but sustainable code bases necessitate order and consistency in modular distinction and communication. A well-organized system with clear boundaries between modules fosters code reusability, ease of maintenance, and scalability, contributing to the long-term success of the project.</p>"},{"location":"modularity/#definition","title":"Definition","text":"<p>Modularity refers to the <code>logical grouping of related code</code>, whether it's classes in an object-oriented language or functions in a structured or functional language. Developers commonly employ modules to organize and group related code together.</p> <p>For architects, understanding how developers package code is crucial, as it significantly impacts the architecture. <code>Tight coupling between packages can make it challenging to reuse one of them for related tasks</code>.</p>"},{"location":"modularity/measuring/","title":"Measuring Modularity","text":""},{"location":"modularity/measuring/#cohesion","title":"Cohesion","text":"<p>Cohesion is a <code>measure of the relationship between parts within a module</code>. In an ideal scenario, a cohesive module contains parts that <code>should remain together</code> since breaking them into smaller pieces would result in increased coupling between modules.</p> <p>Cohesion measures can be ranked from best to worst:</p> <ol> <li> <p>Functional Cohesion: <code>Every part of the module is related to the other</code>, and the module contains everything essential to function.</p> </li> <li> <p>Sequential Cohesion: Two modules interact, where <code>one outputs data that becomes the input for the other.</code></p> </li> <li> <p>Communicational Cohesion: Two modules form a communication chain, <code>where each operates on information and/or contributes to some output</code>. For example, add a record to the database and generate an email based on that information.</p> </li> <li> <p>Procedural Cohesion: Two modules <code>must execute code in a particular order</code>.</p> </li> <li> <p>Temporal Cohesion: Modules are related based on timing dependencies. For example, many systems have a list of seemingly unrelated things <code>that must be initialized at system startup.</code> These different tasks are temporally cohesive.</p> </li> <li> <p>Logical Cohesion: The data within modules is <code>related logically but not functionally</code>. A common example of this type of cohesion exists in Java in the form of the StringUtils package: <code>a group of static methods that operate on String but are otherwise unrelated.</code></p> </li> <li> <p>Coincidental Cohesion: Elements in a module are not related other than <code>being in the same source file.</code> This represents the most negative form of cohesion.</p> </li> </ol> <p>Cohesion is a <code>less precise metric compared to coupling</code>, often left to the discretion of the architect. Consider this module definition:</p> customer_maintenance.py<pre><code>class CustomerMaintenance:\ndef add_customer():\n...\ndef update_customer():\n...\ndef get_customer():\n...\ndef get_customer_orders():\n...\ndef cancel_customer_orders():\n...\n</code></pre> <p>OR</p> customer_order_maintenance.py<pre><code>class CustomerMaintenance:\ndef add_customer():\n...\ndef update_customer():\n...\ndef get_customer():\n...\nclass OrderMaintenance:\ndef get_customer_orders():\n...\ndef cancel_customer_orders():\n...\n</code></pre> <p>There isn't a one-size-fits-all answer. It depends.</p> <ul> <li> <p>Consider if these are the <code>only two operations for OrderMaintenance</code>; if so, collapsing them into CustomerMaintenance might be appropriate.</p> </li> <li> <p>Is Customer Maintenance expected to grow much larger, encouraging developers to look for opportunities to extract behavior?</p> </li> <li> <p><code>Does OrderMaintenance require so much knowledge of Customer</code> information that separating the two modules would require a high degree of coupling to make it functional?</p> </li> </ul> <p>These questions represent the <code>trade-off analysis</code> at the core of a software architect's role. It involves <code>balancing cohesion and coupling to design an effective and maintainable system</code>.</p>"},{"location":"modularity/measuring/#coupling","title":"Coupling","text":"<p>We have effective tools to analyze coupling in code bases, which rely on <code>graph theory</code>. By considering method calls and returns as a call graph, we can perform mathematical analysis to measure coupling.</p> <p>Two essential metrics are <code>afferent</code> and <code>efferent</code> coupling. <code>Afferent</code> coupling quantifies the number of <code>incoming connections</code> to a code artifact (such as a component, class, or function). <code>Efferent</code> coupling, on the other hand, measures the <code>outgoing connections</code> to other code artifacts. These metrics provide valuable insights into the relationships and dependencies among different parts of the codebase.</p>"},{"location":"modularity/measuring/#abstractness","title":"Abstractness","text":"<p>Abstractness is a metric that <code>calculates the ratio of abstract artifacts</code> (such as abstract classes and interfaces) <code>to concrete artifacts</code> (actual implementations). It provides a measure of <code>how much a codebase is focused on abstract concepts versus concrete implementations</code>.</p> <p>For instance, a codebase with no abstractions and just a large, monolithic function lacks abstractness. On the other hand, a codebase with an excessive number of abstractions can become hard for developers to comprehend and navigate, affecting its overall maintainability.</p>"},{"location":"modularity/measuring/#instability","title":"Instability","text":"<p>The instability metric assesses the volatility of a codebase. A <code>highly unstable codebase is prone to breaking when modified</code>, usually due to excessive coupling. For instance, if a class relies heavily on other classes to delegate tasks, it becomes vulnerable to disruptions when any of the called methods undergo changes. High instability indicates that the codebase is more <code>likely to experience adverse effects from alterations, making it less resilient to changes</code>.</p>"},{"location":"modularity/measuring/#distance-from-the-main","title":"Distance from the Main","text":"<p>The distance metric is a derived metric based on instability and abstractness. It envisions an ideal relationship between these two factors, aiming to find the optimal balance between them.</p>"},{"location":"modularity/measuring/#connascence","title":"Connascence","text":"<p>Two components are connascent if a change in one would require the other to be modified in order to maintain the overall correctness of the system.</p> <p>To now more about:</p> <ol> <li> <p>Connascence: Rules for good software design</p> </li> <li> <p>Connascence</p> </li> </ol>"},{"location":"modularity/measuring/#static-connascence","title":"Static Connascence","text":"<p>Static connascence is a measure of <code>source-code-level coupling</code>. Architects assess the types of static connascence to determine the degree of coupling, whether afferent (incoming) or efferent (outgoing). For example, in a microservices architecture, if <code>two services share the same class definition</code>, such as address, we say they are statically connected to each other. Changing the shared class requires modifications in both services.</p>"},{"location":"modularity/measuring/#dynamic-connascence","title":"Dynamic Connascence","text":"<p>Dynamic connascence is a metric that <code>analyzes calls at runtime</code>, focusing on how different parts of the software interact with each other during execution. It helps architects understand the runtime coupling and dependencies between various components and modules, providing insights into <code>potential performance bottlenecks and areas for optimization</code>.</p>"},{"location":"modularity/measuring/#references","title":"References","text":"<ul> <li>Fundamentals of Software Architecture</li> </ul>"}]}